#### 分布式统一ID生成策略抗压

java.util.UUID  

​     这种方式的问题就是比如我要查询一批数据，进行入库时间做数据排序的时候，只能够自己在表里设置一个create_time 给这个字段添加索引然后进行排序.

雪花算法/数据库sequence序列、自增id等........

KeyUtil方法



根据业务来生成ID

最常用使用方式是用带有业务含义的ID生成策略，这种方式也在传统应用系统、特定的场景下非常好用。比如我们现在有一张商品货架表，这张表的数据维度是这样的，比如是按照城市和区域来划分的。



比如北京我们按照1000000基本为度数据，100010为北京的一个区域，100020则为另一个区域，以此类推，200000可能是另一个城市，20010则为另一个城市的区域。那么我们在生成货架信息ID的时候，可以按照前6位为城市和区域的方式进行组织，后面可以拼接一个简单的32位uuid字符串。



查询的时候 根据id可以写sql来区分。



高并发下的ID生成策略服务怎么做？

​        第一，如何解决Id生成的重复问题

​        第二，如何承载高并发ID生成性能瓶颈问题

怎么实现呢？对于以上两个问题，如何进行落地:

​       使用Zookeeper的分布式锁实现。（写QPS上千，Zookeeper性能不行） 大厂肯定是不行

​       使用Redis缓存，利用Redis分布式锁实现  （高并发延迟）    大厂不行

​       业务服务-----》统一id生成服务--------》redis（设置id，失败重新生成id）后面影响大，可能服务降级

业界主流的分布式ID生成器的策略是：

​     实现一：提前加载，也就是预加载的机制（大内存）

​         1.提前加载，也就是预加载机制

​         2.并发获取，采用Disrupt框架区提升性能

​         3.当ID使用超过一定值之后，去补充。

​         4.不同业务线生成规则不一样

​     实现二：单点生成

​         固定一个机器节点来生成一个唯一的id，好处是能做到全局唯一。

​         需要相应的业务规则拼接：机器码+时间戳+自增序列.

高并发的场景下，我们的生成id请求量非常的巨大，就会暴露出NTP问题。

​        NTP网络同步时间协议

​       举个例子，如果单纯的采用：机器码+时间戳 或者 机器码+UUID这种组合，在高并发下可能会有订单重复的问题。

机器码： ABK007  时间戳：1528018092517   ID生成 ABK0071528018092517

NTP就是你的服务器系统的时间会定时去获取，然后进行更新校准，也就是说，我们现在的系统时间是:1528018092517

紧接着我们的服务器进行了NTP的时间校准，这个时候系统时间肯定是向前走的，比如NTP在校准前一刻，系统时间为：1528018092530，恰巧，我们的服务器比标杆服务器走的快，然后经过了一次NTP服务时间校准，时间可能就回到从前，回到过去回到之前的时间 这个时候就会有重复问题。

 所以，我们要解决高并发下的NTP问题就要考虑周全：

 使用：机器码+时间戳+自增序列，即使是我们的时间戳被NTP服务器校准调回，那么我们自增序列永远会在单点下保证自增，比如AtomicLong就是很好的一种原子自增序列计算器。



如果统一ID生成器服务挂掉，自己写一个生成策略兜底保证业务正常进行。





 



​       







