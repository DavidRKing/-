## 关系型数据库主要问题

### 架构

### 索引

### 锁

### 语法

### 理论范式

## 如何设计一个关系型数据库？

设计方案

程序实例

存储管理   缓存机制（LRU等） SQL解析  日志管理（bin-log记录方式）

权限划分（DBA）  容灾机制（错误等） 索引管理 （重点）  锁管理(重点)



RDBMS（存储（文件系统）） --机械硬盘

## 索引模块

创建问题

​     1.为什么要使用索引

​         快速查询数据

​     2.什么样的信息能成为索引

​         主键、唯一键以及普通键等

​     3.索引的数据结构

​         生成索引，建立二叉查找树进行二分查找。

​         生成索引，建立B-tree结构进行查找

​         生成索引，建立B+-tree结构进行查找 （mysql）

​         生成索引，建立Hash机构进行查找

​     4.密集索引和稀疏索引的区别

​              

## 二叉查找树

二叉查找树有可能退化为线性。

平衡二叉树---->IO次数多     



### B-tree

定义：

​    根节点至少包括两个孩子

​    树中每个节点最多含有m个孩子（m>=2）

​    除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子  向上取整

​    所有叶子节点都位于同一层

​    假设每个非终端接点中包含有n个关键字信息，其中

​    1.Ki(i=1...n)为关键字，且关键字顺序升序排序K(i-1)<ki

​    2.关键字的个数n必须满足：【ceil(m/2)-1】<=n<=m-1

​    3.非叶子节点的指针：P[1],P[2],...,p[M];其中P[1]指向关键字小于K[1]的子树,P[M]指向关键字大于K[M-1]的子树，其他P[i]指向关键字属于(K[i-1],K[i])的子树.

​    

让每个索引快尽可能多的存储数据，减少IO次数

### B+tree

   B+树是B树的变体，其定义基本与B树相同，除了：

   非叶子节点的子树指针与关键字的个数相同

   非叶子节点的子树指针P[i],指向关键字值[K[i],K[i+1]]的子树

   非叶子节点只用来保存索引， 数据都保存在叶子节点中

   所有叶子节点均有一个指针指向下一个叶子节点 （支持范围统计，横向统计）​    

### B+tree更适合来做存储索引

​    B+树的磁盘读写代价更低

​    B+树的查询效率更加稳定（任何关键字的查找，都必须找到叶子节点）

​    B+树更有利于对数据库的扫描(范围查询等。)



