## 关系型数据库主要问题

### 架构

### 索引

### 锁

### 语法

### 理论范式

## 如何设计一个关系型数据库？

设计方案

程序实例

存储管理   缓存机制（LRU等） SQL解析  日志管理（bin-log记录方式）

权限划分（DBA）  容灾机制（错误等） 索引管理 （重点）  锁管理(重点)



RDBMS（存储（文件系统）） --机械硬盘

## 索引模块

创建问题

​     1.为什么要使用索引

​         快速查询数据

​     2.什么样的信息能成为索引

​         主键、唯一键以及普通键等

​     3.索引的数据结构

​         生成索引，建立二叉查找树进行二分查找。

​         生成索引，建立B-tree结构进行查找

​         生成索引，建立B+-tree结构进行查找 （mysql）

​         生成索引，建立Hash机构进行查找

​     4.密集索引和稀疏索引的区别

​              

## 二叉查找树

二叉查找树有可能退化为线性。

平衡二叉树---->IO次数多     



### B-tree

定义：

​    根节点至少包括两个孩子

​    树中每个节点最多含有m个孩子（m>=2）

​    除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子  向上取整

​    所有叶子节点都位于同一层

​    假设每个非终端接点中包含有n个关键字信息，其中

​    1.Ki(i=1...n)为关键字，且关键字顺序升序排序K(i-1)<ki

​    2.关键字的个数n必须满足：【ceil(m/2)-1】<=n<=m-1

​    3.非叶子节点的指针：P[1],P[2],...,p[M];其中P[1]指向关键字小于K[1]的子树,P[M]指向关键字大于K[M-1]的子树，其他P[i]指向关键字属于(K[i-1],K[i])的子树.

​    

让每个索引快尽可能多的存储数据，减少IO次数

### B+tree

   B+树是B树的变体，其定义基本与B树相同，除了：

   非叶子节点的子树指针与关键字的个数相同

   非叶子节点的子树指针P[i],指向关键字值[K[i],K[i+1]]的子树

   非叶子节点只用来保存索引， 数据都保存在叶子节点中

   所有叶子节点均有一个指针指向下一个叶子节点 （支持范围统计，横向统计）​    

### B+tree更适合来做存储索引

​    B+树的磁盘读写代价更低

​    B+树的查询效率更加稳定（任何关键字的查找，都必须找到叶子节点）

​    B+树更有利于对数据库的扫描(范围查询等。)

### Hash索引页可以考虑一下

​    缺点：仅仅能满足=，in，不能使用范围查询

​    无法被用来避免数据的排序操作

​    不能利用部分索引键查询

​    不能避免表扫描

​    遇到大量Hash值相等的情况后，性能并不一定会比B-Tree索引高

### BitMap索引是个神器

​     不太适合并发。

### 密集索引和稀疏索引的区别

​      密集索引文件中的每一个搜索码值都对应一个索引值。（叶子节点保存的不仅仅是键值，还保存了其他列的信息。每个表只能创建一个密集索引）

​      稀疏索引文件只为索引码的某些值建立索引项。(根据地址（主键信息），再定位数据)

### 额外的知识

​      InnoDB

​          若一个主键被定义，该主键则作为密集索引。

​          若没有主键定义，该表的第一个唯一非空索引则作为密集索引

​          若不满足以上条件，innodb内部会生成一个隐藏的主键(密集索引 6字节列)

​          非主键索引（稀疏索引）存储相关键位和其对应的主键值，包含两次查找(叶子节点不存储数据的物理地址，而是存储该行的主键值，通过主键再去超找记录)

​     MyISAM使用的稀疏索引

​          主键索引和辅助索引叶子节点都存储记录的物理地址。（一样的。访问辅助索引，不会去访问主键索引）

​      InnoDb

​           .frm(表结构)    .idb(数据索引)

​       MyISAM

​           .frm   .MYI  .MYD

### 索引模块

​     问题与总结

​     为什么要使用索引

​         避免全表扫描查找数据，提升检索效率

​     什么样的信息能成为索引

​         唯一键等。有一定区分性

​     索引的数据结构

​         B+ Tree（主流）       Hash       BitMap

​     密集索引和稀疏索引的区别

​      

​      如何定位并优化mysql

​          

​      联合索引的最左匹配原则的成因

​      索引是建立的越多越好吗？

